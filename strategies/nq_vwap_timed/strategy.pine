//@version=6
strategy("NQ VWAP Trend Pullback",
    overlay=true,
    default_qty_type=strategy.fixed,
    default_qty_value=1,
    commission_type=strategy.commission.cash_per_contract,
    commission_value=1.5,
    slippage=1,
    process_orders_on_close=true,
    calc_on_every_tick=false)

// ——— Professional Execution (Hardcoded) ———
const int marketableTicks = 2
const int timeoutBars     = 3

// ——— Inputs ———
gFilter = "Trend Filters"
macroLen       = input.int(200,    "Macro Trend EMA",          minval=1, group=gFilter)
useRejection   = input.bool(true,  "Require Candle Rejection?", group=gFilter,
    tooltip="Requires Green Close (Long) or Red Close (Short)")

gRisk = "Risk Management"
atrLen         = input.int(14,     "ATR Length",               minval=1, group=gRisk)
slMult         = input.float(2.0,  "Initial Stop (ATR x)",     step=0.1, group=gRisk)
tpMult         = input.float(4.0,  "Take Profit (ATR x)",      step=0.1, group=gRisk)
useTrailing    = input.bool(true,  "Use Trailing Stop?",       group=gRisk)
trailAct       = input.float(1.5,  "Trail Activation (ATR x)", step=0.1, group=gRisk)
trailOffset    = input.float(1.5,  "Trail Offset (ATR x)",     step=0.1, group=gRisk)

gTime = "Session"
startHour      = input.int(9,      "Session Start Hour (NY)",  minval=0, maxval=23, group=gTime)
startMin       = input.int(30,     "Session Start Min (NY)",   minval=0, maxval=59, group=gTime)
endHour        = input.int(15,     "Session End Hour (NY)",    minval=0, maxval=23, group=gTime)
endMin         = input.int(55,     "Session End Min (NY)",     minval=0, maxval=59, group=gTime)

// ——— NY-localized time ———
nyTime = time(timeframe.period, "America/New_York")
nyHour = hour(nyTime)
nyMin  = minute(nyTime)
timeVal = nyHour * 100 + nyMin
startTime = startHour * 100 + startMin
endTime   = endHour * 100 + endMin
inSession = timeVal >= startTime and timeVal < endTime

// ——— Indicators ———
vwapVal = ta.vwap
macroTrend = ta.ema(close, macroLen)
atrVal  = ta.atr(atrLen)

// ——— State ———
var int pendingLongBar  = na
var int pendingShortBar = na

// ——— Signal Logic ———
// 1. Macro Filter: Price relative to 200 EMA
isBullishTrend = close > macroTrend
isBearishTrend = close < macroTrend

// 2. Value Pullback: Price touches/tests VWAP
// Long: Low dips below or touches VWAP, but we close above it
// Short: High pops above or touches VWAP, but we close below it
retestLong  = low <= vwapVal and close > vwapVal
retestShort = high >= vwapVal and close < vwapVal

// 3. Trigger: Rejection Candle (Color match)
rejectionLong  = not useRejection or close > open
rejectionShort = not useRejection or close < open

// Combined Signal
validLong  = inSession and isBullishTrend and retestLong and rejectionLong and barstate.isconfirmed
validShort = inSession and isBearishTrend and retestShort and rejectionShort and barstate.isconfirmed

// ——— Limit Price ———
tick = syminfo.mintick
limitLong  = close + marketableTicks * tick
limitShort = close - marketableTicks * tick

// ——— Execution: Entry ———
if validLong and strategy.position_size == 0 and na(pendingLongBar)
    strategy.entry("L", strategy.long, limit=limitLong, comment="Trend Pullback")
    pendingLongBar := bar_index

if validShort and strategy.position_size == 0 and na(pendingShortBar)
    strategy.entry("S", strategy.short, limit=limitShort, comment="Trend Pullback")
    pendingShortBar := bar_index

// ——— Execution: Management (ATR Stops/Targets) ———
if strategy.position_size != 0
    // Reset pending flags if we are in a trade
    pendingLongBar := na
    pendingShortBar := na

    float exitStop = na
    float exitTarget = na

    // Calculate Stop/Target based on AVG Entry Price and current ATR
    if strategy.position_size > 0
        exitStop   := strategy.position_avg_price - (atrVal * slMult)
        exitTarget := strategy.position_avg_price + (atrVal * tpMult)
    else
        exitStop   := strategy.position_avg_price + (atrVal * slMult)
        exitTarget := strategy.position_avg_price - (atrVal * tpMult)

    // Hard Stop / Hard Target
    strategy.exit("Exit L", "L", stop=exitStop, limit=exitTarget, comment_loss="SL", comment_profit="TP")
    strategy.exit("Exit S", "S", stop=exitStop, limit=exitTarget, comment_loss="SL", comment_profit="TP")

    // Custom Trailing Implementation
    if useTrailing and strategy.position_size > 0
        float activLevel = strategy.position_avg_price + (atrVal * trailAct)
        if high > activLevel
            float newStop = high - (atrVal * trailOffset)
            if newStop > exitStop
                strategy.exit("Trail L", "L", stop=newStop, comment="Trail")

    if useTrailing and strategy.position_size < 0
        float activLevel = strategy.position_avg_price - (atrVal * trailAct)
        if low < activLevel
            float newStop = low + (atrVal * trailOffset)
            if newStop < exitStop
                strategy.exit("Trail S", "S", stop=newStop, comment="Trail")

// ——— Timeout Logic (Cancel Waiting Orders) ———
if strategy.position_size == 0 and not na(pendingLongBar) and (bar_index - pendingLongBar) >= timeoutBars
    strategy.cancel("L")
    pendingLongBar := na

if strategy.position_size == 0 and not na(pendingShortBar) and (bar_index - pendingShortBar) >= timeoutBars
    strategy.cancel("S")
    pendingShortBar := na

// ——— Forced EOD Exit ———
if nyHour >= endHour and nyMin >= endMin
    strategy.close_all(comment="EOD")
    pendingLongBar := na
    pendingShortBar := na

// ——— Visuals ———
plot(macroTrend, "Macro Trend (200 EMA)", color=color.blue, linewidth=2)
plot(vwapVal,    "VWAP",                  color=color.orange, linewidth=2)

// Color background to show "Trend Regime"
bgcolor(isBullishTrend ? color.new(color.green, 95) : isBearishTrend ? color.new(color.red, 95) : na)
